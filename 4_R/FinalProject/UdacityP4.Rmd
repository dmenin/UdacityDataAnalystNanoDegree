<!-- 
---
title: "UdacityP4Project"
author: "Diego Menin"
date: "Wednesday, July 15, 2015"
output: html_document
---
-->



<center> <h1>Project Overview</h1> </center>

<br>

<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In this project, I  will use R to apply exploratory data analysis techniques on a red  wine dataset trying to answer the guideline question: "Which chemical properties influence the quality of red wines"?
This report is not to be seen (and won't be presented) as a "final report" you'd present to a possible stakeholder. The main goal of this project is to document an EDA process from scratch. Exploratory Data Analysis (EDA) is the numerical and graphical examination of data characteristics and relationships before formal, rigorous statistical analyses are applied.
</p>

<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**As the project description  states (and I quote):** *Plots in this analysis do not need to be polished with labels, units, and titles; these plots are exploratory (quick and dirty). They should, however, be of the appropriate type and effectively convey the information you glean from them - You can iterate on a plot in the same R chunk, but you don't need to show every plot iteration in your analysis*
In the end there will be a "Final Plots and Summary" where I selected three plots from the analysis to polish and share with more insights.
</p>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This project is divide in the following sections:

1. Dataset: Contains an overview of the dataset used and an explanation of each one of its variable. 
2. Final Plots and Summary
3. Reflection

<br>

## The DataSet

<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This tidy data set contains 1,599 observation  of red wines with 11 variables on the chemical properties of the wine. 
The inputs include objective tests (e.g. PH values) and the output is based on sensory data (median of at least 3 evaluations made by wine experts). Each expert graded the wine quality between 0 (very bad) and 10 (very excellent).
</p>

<br>
<br>
###Attributes description:

1. **fixed acidity (tartaric acid - g / dm^3):** most acids involved with wine or fixed or non-volatile (do not evaporate readily)
2. **volatile acidity(acetic acid - g / dm^3):** the amount of acetic acid in wine, which at too high of levels can lead to an unpleasant, vinegar taste
3. **citric acid(g / dm^3):** found in small quantities, citric acid can add 'freshness' and flavour to wines
4. **residual sugar(g / dm^3):** the amount of sugar remaining after fermentation stops, it's rare to find wines with less than 1 gram/litter and wines with greater than 45 grams/litter are considered sweet
5. **chlorides(sodium chloride - g / dm^3:** the amount of salt in the wine
6. **free sulphur dioxide(mg / dm^3):** the free form of SO2 exists in equilibrium between molecular SO2 (as a dissolved gas) and bisulfide ion; it prevents microbial growth and the oxidation of wine
7. **total sulphur dioxide(mg / dm^3):** amount of free and bound forms of S02; in low concentrations, SO2 is mostly undetectable in wine, but at free SO2 concentrations over 50 ppm, SO2 becomes evident in the nose and taste of wine
8. **density(g / cm^3):** the density of water is close to that of water depending on the percent alcohol and sugar content
9. **pH:** describes how acidic or basic a wine is on a scale from 0 (very acidic) to 14 (very basic); most wines are between 3-4 on the pH scale
10. **sulphates(potassium sulphate - g / dm3):** a wine additive which can contribute to sulphur dioxide gas (S02) levels, which acts as an antimicrobial and antioxidant
11. **alcohol(% by volume):** the percent alcohol content of the wine
12. **quality:** Output variable based on sensory data(score between 0 and 10)


```{r, echo=FALSE, include=FALSE}
setwd("C:/git/UdacityDataAnalystNanoDegree/4_R/FinalProject/")
df<-read.csv("wineQualityWhites.csv")
library(plyr)
library(dplyr)
library(sfsmisc)
library(reshape2 )
library(ggplot2)
library(gridExtra)
library (corrplot)
library(caret)
```

<br>
<br>

###Understanding the data

<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The first thing that caught my attention was that the quality variable (the one we are mainly trying to understand) is begin stored as an integer - which is no good because even ought it is intuitive (the higher the quality, the better) it doesn't necessary mean that a quality 4 wine is twice as good as a quality 2 wine and twice as bad as a quality 8 - it's just a numeric scale, so I transformed it to a factor.
BY the way, from this point on I will refer to "quality X wines" simply as QX to save space.
</p>
```{r}
df$quality <- as.factor(df$quality)
```


<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
My second step was to see how many observation of each wine quality do we have by creating a histogram on the quality variabl:
</p>

<!-- 
```{r, echo=FALSE}
ggplot(data=df,aes(x=quality))+
  geom_bar(aes(y = (..count..)),fill="orange")+
  geom_text(aes(y = (..count..),label =   ifelse((..count..)==0,"",scales::percent((..count..)/sum(..count..)))), stat="bin",colour="darkgreen")
```
-->

<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
The fact that the data is not evenly distributes (it's actually normally distributed) is a bad thing to us because we have very few observations on the tails - meaning that its quite hard to identify an "excellent" wine when they only appear on 0.1% of your dataset (5 observations). We can also see that there are no Q1, Q2 and Q10 wines on this dataset.
</p>


<br>
<br>

####Single variable Analysis

<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The next thig was to  analyse each variable individually inside each wine quality by plotting individual boxplots and bar charts for each one of them. **Important note:** To avoid plotting 18 charts here, I summarized then in two big plots. I understand that they may look squeezed together but while trying to fit on the screen but bear in mind that I initially looked at them individually.
</p>

<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
I used the boxplots mainly to get an idea of the data range and to find potential outliers:
</p?

<!-- 
```{r, echo=FALSE,  fig.width = 12, fig.height = 16}

melt_data <- melt(df,id.vars=c("X","quality"))


plots <- dlply(melt_data,.(variable),function(chunk)
{
  ggplot(data=chunk, aes(x=factor(quality), y = value)) + geom_boxplot()+  stat_summary(fun.y=mean,geom = 'point', shape = 4) +  labs(y=unique(chunk$variable))
})

do.call(grid.arrange,c(plots,ncol=2))
```
-->


<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Here are the results:

1. **fixed acidity:**  very few outliers; 
2. **volatile acidity:** 160 outliers but only over the upper outer fence;
3. **citric acid:** 220 outliers over the upper outer fence; a few bellow the lower outer fence;  quite a few values close to 0 - specially on Q4 and Q5 wines - is this an indication of poor wine quality?;
4. **residual sugar:** almost no outliers, except for observation 2782 which has a value of 65 when the upper whisker (disregarding quality) is 22; that is clearly an erroneous observation on Q6 so I decided to remove it from the dataset to avoid having to filter it from now on;
5. **chlorides:** 160 outliers but only over the upper outer fence;
6. **free sulfur dioxide:** no outliers;
7. **total sulfur dioxide:** no outliers;
8. **density:** no outliers;
9. **pH:** very few outliers;
10. **sulphates:** 150 outliers but only over the upper outer fence;
11. **alcohol:** no outliers;

```{r, echo=FALSE}
df<- df[!df$X == 2782, ]
df[,c("X")] <- list(NULL)

```

<br>
<br>
<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I also used bar plots to visualise the average of each measure on different wine qualities. This has proven to be a much more interesting analysis as I could, among other things, to plot a trend line to see how the average "behave" between different wine qualities.
</p>


<!-- 
```{r, echo=FALSE,  fig.width = 12, fig.height = 16}
plots <- dlply(melt_data,.(variable),function(chunk)
{
  ggplot(data= chunk) +  aes(x = factor(quality), y = value)+
    stat_summary(aes(fill = factor(quality)), fun.y=mean, geom="bar")+
    stat_summary(aes(label=round(..y..,2)), fun.y=mean, geom="text", size=6, vjust = 1)  +  
    labs(y=unique(chunk$variable)) + theme(legend.position="none") +
    geom_smooth(method = "lm", se=FALSE, color="black", type='dotted', aes(group=1), size =1,lty = 2)
    
})
do.call(grid.arrange,c(plots,ncol=2))
```
-->

<br>
<br>
<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Here are the results:
</p>

1. **fixed.acidity:** This seems to be a tricky one, as the average quantity decreases, the quality seems to increase, except for Q9 where it is higher than Q4. So I went back to the fixed.acidity boxplot on Q9 and saw that there is an outlier (observation 775). So I tried to remove it to see it if affects the report, but even though it brought the average down to 7, it still maintains the same behaviour we are experiencing.

2. **volatile.acidity:** We seem to be getting better wines with less acidity, but again, even though the average decreases from 4 to 7, it slightly increases on Q8 and Q9 .

3. **citric.acid:** in this case is undeniable that more acid wines were classified as better.

4. **residual.sugar:** Looking at sugar we seem to see a trend where less sugary wines seem to be classified as better (even though "7" is not as right as I would expect). Interesting the drop from Q8 to Q9 and the fact that Q9's average is closer to Q4's average than Q8 average.

5. **chlorides:** clearly follows a descending patter, where we'd be looking for less chlorides to get a better wine

6. **free.sulfur.dioxide:** Too much is correlated with a very bad wine (Q3) where too little is not good either (Q4). Pretty static otherwise, anything between 36.4 and 33.4 is good, the latter being ideal.

7. **total.sulfur.dioxide:** "descending" pattern similar to the one found on residual sugar. Looking at the two graph I expect that these two variables are correlated (and in fact they are, I'll show latter on that their correlation is 0.4)

8. **density:** doesn't seem to matter that much, the difference between worst and best being 0.0034

9. **pH:** we see a tendency of having better quality with higher PH (not very steep though)                  

10. **alcohol:** same behaviour as pH, only in this case the slope seems to be bigger

11. **sulphates:**  this is a tricky one, from  Q3 to Q7we seem to be getting better quality as the number of sulphates increases, which doesn't hold true for q8 and Q9


<br>
<br>

<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;So, even though I got an idea of each variable relationship with average quality, I wanted to expand this analysis a little trying to find out how much of the Wine's quality is explained by each individual variable.
In order to do that, I choose to run a simple linear regression between quality and each variable.
</p>

<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It's important to reinstate that since "wine quality" is a factor (a categorical variable), it doesn't make sense to talk about correlation between it and the variables because it doesn't have a numerical value that can go up and down. 
But there are measures of strength of association we can use that are somewhat analogous. 
As an example, let's look at the "alcohol" variable.  By using "alcohol "as the reference level for "Quality", we can perform a regression.
</p>

```{r}
model.lm <- lm(alcohol ~ quality, data =df)
summary(model.lm)
```


<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We can interpret the estimated intercept as giving the mean "alcohol" on Q3 3  wines as 10.3450 (% by volume), and the estimated coefficients for the subsequent qualities as showing how much it changed compared with Q3
For example, the estimate on Q4 is showing it having on average -0.1925 (% by volume) less than Q3 and the coefficient on Q9 shows it having 1.8350 (% by volume) more than "quality 3" and so on. 
</p>

<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The coefficient of determination R2=0.2199 is quite small (one interpretation it is that this model explains only 22% of variance). 
</p>

<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note that 0.2199 isn't the correlation between "alcohol" and "quality" - we can't correlate those two variables because quality is categorical. What it actually represents is the correlation between the observed values for alcohol, and the ones predicted (fitted) by the model. Both of these variables are numerical so we are able to correlate them. In fact the fitted values are just the mean durations for each group:
</p>

```{r}
tail(model.lm$fitted)
tail(select(df, alcohol, quality))
```


<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We can easily see that the 10.57486 on the fitted model is actually 10.3450 (average) + 0.2299  (coefficient from wine Q6 - which is the quality for observation 4898)
</p>


<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; But that was only one variable. 
Bellow I run a similar code to output the coefficients of all measures on the same grid. On the last line I add the R2 for that particular measure.
</p>


```{r}
fit_model <- function(variable, data, name)
{
  model.lm <- lm(variable ~ quality, data = data) #run the regression
  s<-summary(model.lm)
  x<-as.data.frame(round(s$coefficients[,1],4)) #get the coeficients from the summary
  names(x) <- name # name the column
  rsq <- round(summary(model.lm)$r.squared,4) #get r-squared
  x<-rbind(x,rsq)  #and add it to the data frame
  rownames(x)[8] <-"r-squared"  #name the row
  x
}

grid <- NULL
i = 1
for(n in names(df))
{  
  if (n != 'quality') {
    if (is.null(grid)){
      grid<-fit_model(df[,i], df, n)
    } else {
      grid<-cbind(grid,fit_model(df[,i], df, n) )
    }
    i = i+1  
  }
}

grid
```


<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Looking at the r-squares we can see that no measure by itself explains much of the model. 
Actually, alcohol and density are the two variables that individually explain more about the model (21% and 11% respectively) followed by acidity with 7% and chlorides with roughly 5%. 
</p>


<br>
<br>

####Dual variable Analysis (correlation)
<br>

<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I started analysing the correlation between all the variables by plotting the full matrix where on the top right we can see the correlation strength coloured (darker blue meaning higher correlation - positive or negative) and on the symmetric bottom left only the values (I am rounding the correlation to 2 decimal places only on the graph to make visualization easier: 
</p>


```{r, fig.width = 8, fig.height = 8, warning=FALSE}
col1 <- colorRampPalette(c("#00007F","blue","#007FFF","cyan","white", "cyan", "#007FFF", "blue","#00007F"))
c<-cor(select(df, -quality))
c2 <-round(c, digits=2)


corrplot(c2, method="color", col=col1(20), cl.length=21,order = "AOE", addCoef.col="grey", tl.srt=45,tl.col="black")
corrplot(c,add=TRUE, type="lower", method="number",order="AOE", col="black",
         diag=FALSE,tl.pos="n", cl.pos="n", tl.srt=45)

```



<p style='text-align: justify;'>
We can straight away see that the top correlations are:

1. alcohol and residual.sugar: -0.4506312
2. alcohol and chlorides: -0.3601887
3. alcohol and total.sulfur.dioxide: -0.4488921
4. alcohol and density: -0.7801376
5. total.sulfur.dioxide and residual.sugar: 0.4014393
6. total.sulfur.dioxide and free.sulfur.dioxide: 0.6155010
7. total.sulfur.dioxide and density: 0.5298813
8. density and residual.sugar:  0.8389665
9 .pH and fixed.acidity:  -0.4258583
</p>
<br>
<p style='text-align: justify;'>
And this is the number of times each variable is "moderately correlated (> 0.35 or < -0.35)" with another: alcohol: 4; total.sulfur.dioxide: 4; residual.sugar: 3; density: 3; free.sulfur.dioxide: 1; fixed.acidity: 1; pH: 1; 
chlorides: 1;
</p>
<br>
<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Just to be sure I'm not missing any other type of correlation, I am plotting the least correlated pair of variables (free.sulfur.dioxide and pH) and for comparison, the most correlated variables (residual.sugar and density) on the side.
</p>


```{r, warning=FALSE, fig.width = 12, message=FALSE}
lesscorrelated<- ggplot(aes(x = free.sulfur.dioxide, y = pH), data=df) + 
                  geom_point()+
                  geom_smooth(method = 'auto', color = 'red')+
                  xlim(0, quantile(df$free.sulfur.dioxide,0.99)) 
  

morecorrelated<- ggplot(aes(x = residual.sugar, y = density), data=df) + 
                geom_point()+ geom_smooth(, color = 'red') +
                xlim(0, quantile(df$residual.sugar,0.99)) 

grid.arrange(lesscorrelated, morecorrelated, ncol=2)
```

<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Looking at the plot on the left there does not seem to be any connection, linear or non-linear between pH and free sulfur dioxide. On the right side, we do see the positive correlation between sugar and density, which is expected according to the [brix scale](https://en.wikipedia.org/wiki/Brix) (as the sugar content increases, the density increases)
</p>
<br>


####Plotting the top correlations:

<p style='text-align: justify;'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Based on the values above, lets see how the most correlated variables behave among each other. 
</p>

<br>
**With Alcohol:**
```{r, fig.width = 12, fig.height = 12, warning=FALSE, message=FALSE}
p1<-ggplot(aes(x =  log10(alcohol), y =log10(residual.sugar) ), data=df) + 
  geom_point() +
  geom_smooth(method = 'auto', color = 'red')

p2<-ggplot(aes(x =  log10(alcohol), y =log10(chlorides) ), data=df) + 
  geom_point() +
  geom_smooth(method = 'auto', color = 'blue')  

p3<-ggplot(aes(x =  log10(alcohol), y =log10(density) ), data=df) + 
  geom_point() +
  geom_smooth(method = 'auto', color = 'orange')  

p4<-ggplot(aes(x =  log10(alcohol), y =log10(total.sulfur.dioxide) ), data=df) + 
  geom_point() +
  geom_smooth(method = 'auto', color = 'violet')  

grid.arrange(p1,p2,p3,p4, ncol=2)
```
  
<br>
**With Total Sulfur Dioxide:**
```{r, fig.width = 10, fig.height = 10, warning=FALSE, message=FALSE}
p1<-ggplot(aes(x =  log10(total.sulfur.dioxide), y =log10(residual.sugar) ), data=df) + 
  geom_point() +
  geom_smooth(method = 'auto', color = 'red')

p2<-ggplot(aes(x =  log10(total.sulfur.dioxide), y =log10(free.sulfur.dioxide) ), data=df) + 
  geom_point() +
  geom_smooth(method = 'auto', color = 'blue')  

p3<-ggplot(aes(x =  log10(total.sulfur.dioxide), y =log10(density) ), data=df) + 
  geom_point() +
  geom_smooth(method = 'auto', color = 'violet')  

p4<-ggplot(aes(x =  log10(total.sulfur.dioxide), y =log10(alcohol) ), data=df) + 
  geom_point() +
  geom_smooth(method = 'auto', color = 'orange')  

grid.arrange(p1,p2,p3,p4, ncol=2)
```

<br>
**Density and residual.sugar:**
```{r, fig.width = 12, fig.height = 6, warning=FALSE, message=FALSE}
ggplot(aes(x =  log10(residual.sugar), y = log10(density)), data=df) + 
  geom_point() +
  geom_smooth(method = 'auto', color = 'red')  
```

<br>
**pH and fixed.acidity*:*
```{r, fig.width = 12, fig.height = 5, warning=FALSE, message=FALSE}
#pH and fixed.acidity:  -0.426296256
ggplot(aes(x =  log10(pH), y = log10(fixed.acidity)), data=df) + 
  geom_point() +
  geom_smooth(method = 'auto', color = 'red')  
```







